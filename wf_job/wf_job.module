<?php

/**
 * @file
 * Workflow job module functions.
 */

/**
 * Implements hook_entity_info().
 */
function wf_job_entity_info() {
  $info = array();

  $info['wf_job'] = array(
    'label' => t('Workflow Job'),
    'entity class' => 'WfJob',
    'controller class' => 'WfJobController',
    'extra fields controller class' => 'EntityPropertyExtraFieldsController',
    'base table' => 'wf_job',
    'revision table' => 'wf_job_revision',
    'fieldable' => TRUE,
    'entity keys' => array(
      'bundle' => 'bundle',
      'id' => 'jid',
      'revision' => 'vid',
      'label' => 'job',
      'uuid' => 'uuid',
      'revision uuid' => 'vuuid',
    ),
    'bundle keys' => array('bundle' => 'bundle'),
    'bundles' => array(),
    'load hook' => 'wf_job_load',
    'view modes' => array(
      'full' => array(
        'label' => t('Full Job'),
        'custom settings' => FALSE,
      ),
    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'module' => 'wf_job',
    'uuid' => TRUE,
    'access callback' => 'wf_job_access',
    'views controller class' => 'WfJobViewsController',
    'default_revision' => TRUE,
  );

  $info['wf_job_bundle'] = array(
    'label' => t('Job Type'),
    'entity class' => 'Entity',
    'controller class' => 'EntityAPIControllerExportable',
    'base table' => 'wf_job_bundle',
    'fieldable' => FALSE,
    'bundle of' => 'wf_job',
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'bundle',
      'name' => 'bundle',
      'label' => 'label',
      'status' => 'status',
      'module' => 'module',
    ),
    'module' => 'wf_job',
    'admin ui' => array(
      'path' => 'admin/structure/job-types',
      'file' => 'includes/wf_job.admin.inc',
    ),
    'access callback' => 'wf_job_type_access',
  );

  foreach (wf_job_load_bundles() as $name => $bundle) {
    $info['wf_job']['bundles'][$name] = array(
      'label' => $bundle->label,
      'admin' => array(
        'path' => 'admin/structure/job-types/manage/%',
        'real path' => 'admin/structure/job-types/manage/' . $name,
        'bundle argument' => 4,
        'access arguments' => array('administer jobs'),
      ),
    );
  }

  $info['wf_job_status'] = array(
    'label' => t('Job Status'),
    'plural label' => t('Job Statuses'),
    'entity class' => 'Entity',
    'controller class' => 'EntityAPIControllerExportable',
    'base table' => 'wf_job_status',
    'fieldable' => FALSE,
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'jsid',
      'name' => 'machine_name',
      'label' => 'status',
      'status' => 'export_state',
      'module' => 'module',
    ),
    'module' => 'wf_job',
    'admin ui' => array(
      'path' => 'admin/structure/job-statuses',
      'file' => 'includes/wf_job.status.admin.inc',
    ),
    'access callback' => 'wf_job_type_access',
  );

  return $info;
}

/**
 * Implements hook_menu().
 */
function wf_job_menu() {
  $items = array();
  $items['job/add'] = array(
    'title' => 'Create new job',
    // Grant the user access to this page regardless of other permissions.
    'access callback' => TRUE,
    'page callback' => 'wf_job_page_add',
    'file' => 'includes/wf_job.pages.inc',
  );

  foreach (array_keys(wf_job_load_bundles()) as $bundle) {
    $items['job/add/' . $bundle] = array(
      'title' => 'Create new job',
      'page callback' => 'wf_job_add',
      'page arguments' => array(2),
      'access callback' => 'wf_job_access',
      'access arguments' => array('create', NULL, NULL, $bundle),
      'file' => 'includes/wf_job.pages.inc',
    );
  }

  $items['job/%wf_job'] = array(
    'access callback' => 'wf_job_access',
    'access arguments' => array('view', 1),
    'page callback' => 'wf_job_view',
    'page arguments' => array(1),
    'file' => 'includes/wf_job.pages.inc',
  );
  $items['job/%wf_job/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['job/%wf_job/edit'] = array(
    'title' => 'Edit',
    'access callback' => 'wf_job_access',
    'access arguments' => array('edit', 1),
    'page callback' => 'wf_job_edit',
    'page arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/wf_job.pages.inc',
  );
  $items['job/%wf_job/delete'] = array(
    'title' => 'Delete',
    'access callback' => 'wf_job_access',
    'access arguments' => array('delete', 1),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wf_job_delete_form', 1),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/wf_job.pages.inc',
    'weight' => 10,
  );
  $items['job/%wf_job/start'] = array(
    'title callback' => 'wf_job_action_title',
    'title arguments' => array(1, 'start'),
    'access callback' => 'wf_job_access',
    'access arguments' => array('start', 1),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wf_job_action_start_form', 1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'includes/wf_job.admin.inc',
    'weight' => -10,
  );
  $items['job/%wf_job/to-dev'] = array(
    'title callback' => 'wf_job_action_title',
    'title arguments' => array(1, 'return to dev'),
    'access callback' => 'wf_job_access',
    'access arguments' => array('to-dev', 1),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wf_job_action_to_dev_form', 1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'includes/wf_job.admin.inc',
    'weight' => -10,
  );
  $items['job/%wf_job/reallocate'] = array(
    'title callback' => 'wf_job_action_title',
    'title arguments' => array(1, 'reallocate'),
    'access callback' => 'wf_job_access',
    'access arguments' => array('reallocate', 1),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wf_job_action_reallocate_form', 1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'includes/wf_job.admin.inc',
    'weight' => 9999,
  );
  $items['job/%wf_job/propose'] = array(
    'title callback' => 'wf_job_action_title',
    'title arguments' => array(1, 'propose'),
    'access callback' => 'wf_job_access',
    'access arguments' => array('propose', 1),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wf_job_action_propose_form', 1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'includes/wf_job.admin.inc',
    'weight' => -10,
  );
  $items['job/%wf_job/review'] = array(
    'title callback' => 'wf_job_action_title',
    'title arguments' => array(1, 'review'),
    'access callback' => 'wf_job_access',
    'access arguments' => array('review', 1),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wf_job_action_review_form', 1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'includes/wf_job.admin.inc',
    'weight' => -10,
  );
  $items['job/%wf_job/visit'] = array(
    'title' => 'Visit Sandbox',
    'access callback' => 'wf_job_access',
    'access arguments' => array('visit', 1),
    'page callback' => 'wf_job_visit',
    'page arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
    'weight' => 10,
  );
  $items['job/%wf_job/login'] = array(
    'title' => 'Login to dev sandbox',
    'access callback' => 'wf_job_access',
    'access arguments' => array('login', 1),
    'page callback' => 'wf_job_login_page',
    'page arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
    'weight' => 20,
  );
  $items['job/%wf_job/update-code'] = array(
    'title' => 'Update code',
    'access callback' => 'wf_job_access',
    'access arguments' => array('update_code', 1),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wf_job_update_job_code_form', 1),
    'type' => MENU_LOCAL_ACTION,
    'weight' => 50,
  );
  $items['admin/content/jobs/drush-aliases'] = array(
    'title' => 'Download drush aliases',
    'description' => 'Admin page for exporting drush wf.aliases.drushrc.php file',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wf_job_export_drush_aliases_form'),
    'access arguments' => array('export job aliases'),
    'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
    'file' => 'includes/wf_job.pages.inc',
  );
  $items['admin/structure/job-types/manage/%wf_job_type'] = array(
    'title' => 'Config job type',
    'access arguments' => array('administer jobs'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('bundle_key_form', 4),
    'type' => MENU_CALLBACK,
    'file' => 'example.admin.inc',
  );
  $items['admin/structure/job-types/manage/%wf_job_type/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/config/development/wf_job'] = array(
    'title' => 'WF Job',
    'description' => 'Configure job settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wf_job_admin_settings'),
    'access arguments' => array('administer jobs'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/wf_job.admin.inc',
  );
  return $items;
}


/**
 * Implements hook_permission().
 */
function wf_job_permission() {
  $perms = array();

  $perms['administer job types'] = array(
    'title' => t('Administer jobs'),
    'description' => t('Administer job types and configuration'),
  );

  $perms['manage jobs'] = array(
    'title' => t('Manage jobs'),
    'description' => ('Create, edit or delete any job'),
  );

  foreach (array_keys(wf_job_load_bundles()) as $bundle) {
    $perms += wf_job_list_permissions($bundle);
  }

  $envs = wf_environment_list_names(TRUE, variable_get('wf_environment_default'));
  $actions = array('propose job for', 'rewiew job before');
  foreach ($envs as $env) {
    foreach ($actions as $action) {
      $key = filter_xss("{$action} {$env}");
      $perms[$key] = array(
        'title' => filter_xss(ucfirst($key)),
      );
    }
  }

  $perms['review own jobs'] = array(
    'title' => t('Review own jobs'),
  );

  $perms['return job to dev'] = array(
    'title' => t('Return job to dev'),
  );

  $perms['reallocate job'] = array(
    'title' => t('Reallocate job'),
  );

  return $perms;
}

/**
 * Helper function to create wf_job permission list for a given wf_job type.
 *
 * @param string $type
 *   The machine-readable name of the wf_job type.
 *
 * @return array
 *   An array of permission names and descriptions.
 */
function wf_job_list_permissions($type) {
  // Build standard list of wf_job permissions for this wf_job type.
  $actions = array('view', 'edit', 'delete', 'login', 'visit', 'update code');

  $perms = array();
  $perms["create $type job"] = array(
    'title' => t(
      '%type_name: Create new job',
      array('%type_name' => $type)
    ),
  );
  foreach ($actions as $action) {
    $perms["$action own $type job"] = array(
      'title' => t(
        '%type_name: %action own job', array(
          '%action' => ucfirst($action),
          '%type_name' => $type,
        )
      ),
    );
    $perms["$action any $type job"] = array(
      'title' => t(
        '%type_name: %action any job', array(
          '%action' => ucfirst($action),
          '%type_name' => $type,
        )
      ),
    );
  }
  return $perms;
}

/**
 * Implements hook_wf_job_url_login().
 */
function wf_job_wf_job_url_login() {
  return wf_job_login_plugins();
}

/**
 * Implements hook_wf_job_url_visit().
 */
function wf_job_wf_job_url_visit() {
  return wf_job_login_plugins();
}

/**
 * Implements hook_wf_job_sandbox_domain().
 */
function wf_job_wf_job_sandbox_domain() {
  return wf_job_login_plugins();
}

/**
 * Helper function to return the WF Job URL plugin info.
 */
function wf_job_login_plugins() {
  $plugins = array();

  $plugins['wf_job_links'] = array(
    'title' => t('Generic WF Job'),
    'description' => t('Generic URL generator plugin.'),
    'handler' => 'WfJobLinks ',
    'file' => 'plugins/wf_job.url.inc',
  );

  return $plugins;
}

/**
 * Access callback for the entity API.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create', 'delete'
 *   or just 'edit' (being the same as 'create' or 'update').
 * @param $entity
 *   (optional) A profile to check access for. If nothing is given, access for
 *   all profiles is determined.
 * @param $account
 *   (optional) The user to check for. Leave it to NULL to check for the global user.
 * @param $entity_type
 *   (optional) Leave it to NULL to get the property from $entity.
 *
 * @return boolean
 *   Whether access is allowed or not.
 */
function wf_job_access($op, $entity, $account = NULL, $entity_type = NULL) {
  ctools_include('plugins');
  $handler = &drupal_static(__FUNCTION__);
  if (!$handler) {
    $plugin = variable_get('wf_job_acl_plugin', 'standard');
    $class_name = ctools_plugin_load_class('wf_job', 'acl', $plugin, 'handler');
    $handler = new $class_name();
  }

  if (!isset($account)) {
    global $user;
    $account = $user;
  }

  if (!isset($entity_type)) {
    $entity_type = $entity->bundle;
  }

  return $handler->hasAccess($op, $entity, $account, $entity_type);
}

/**
 * Helper function to check for granular permissions for the job type.
 *
 * @param string $action
 *   Action being executed.
 * @param string $type
 *   Current job type.
 * @param object $job
 *   Current job.
 * @param object $user
 *   User account to check the permission.
 *
 * @return boolean
 *   $user can perform this $action on this job $type.
 */
function wf_job_granular_access($action, $type, $job, $user) {
  $perm = "{$action} any {$type} job";

  if (user_access($perm, $user)) {
    return TRUE;
  }

  $perm = "{$action} own {$type} job";
  return $user->uid == $job->owner && user_access($perm, $user);
}

/**
 * Access callback for the entity API.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create', 'delete'
 *   or just 'edit' (being the same as 'create' or 'update').
 * @param $profile
 *   (optional) A profile to check access for. If nothing is given, access for
 *   all profiles is determined.
 * @param $account
 *   (optional) The user to check for. Leave it to NULL to check for the global user.
 *
 * @return boolean
 *   Whether access is allowed or not.
 */
function wf_job_type_access($op, $type = NULL, $account = NULL) {
  return user_access('administer jobs', $account);
}

/**
 * Implements hook_views_api().
 */
function wf_job_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Page callback for job/%wf_job/update-code.
 */
function wf_job_update_job_code_form($form, $form_state, $job) {
  $job_uri = entity_uri('wf_job', $job);

  return confirm_form(
    $form,
    t('Are you sure you want to update the code for job <strong>@job</strong>', array('@job' => entity_label('wf_job', $job))),
    $job_uri['path'],
    t('This action takes at least a few minutes to complete.'),
    t('Update code'),
    t('Cancel')
  );
}

/**
 * Submit handler for wf_job_update_job_code_form.
 */
function wf_job_update_job_code_form_submit($form, &$form_state) {
  // Gets the current job and fires wf_job_update_code_submit rules event.
  // Then redirects to the view of the job.
  $job = reset($form_state['build_info']['args']);

  rules_invoke_event('wf_job_update_code_submit', $job);

  $uri = entity_uri('wf_job', $job);
  $form_state['redirect'] = url($uri['path'], $uri['options']);

  drupal_set_message(t('A code update for this job will commence shortly.'));
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function wf_job_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Add action link to 'job/add' on 'admin/content/jobs' page.
  if ($root_path == 'admin/content/jobs') {
    $item = menu_get_item('job/add');
    if ($item['access']) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
      );
    }
  }
}

/**
 * Implements hook_admin_paths().
 */
function wf_job_admin_paths() {
  $paths = array(
    'job/*/edit' => TRUE,
    'job/*/delete' => TRUE,
    'job/*/revisions' => TRUE,
    'job/add' => TRUE,
    'job/add/*' => TRUE,
  );
  return $paths;
}

/**
 * Implements hook_entity_property_info().
 */
function wf_job_entity_property_info() {

  $info = array();
  $properties = array();

  $properties['jid'] = array(
    'label' => t('ID'),
    'type' => 'integer',
    'description' => t('The unique job identifier.'),
    'schema field' => 'jid',
    'extra_fields' => array('display'),
  );

  $properties['vid'] = array(
    'label' => t('Revision ID'),
    'type' => 'integer',
    'description' => t('The unique job revision identifier.'),
    'schema field' => 'vid',
    'extra_fields' => array('form'),
  );

  $properties['uuid'] = array(
    'label' => t('UUID'),
    'type' => 'integer',
    'description' => t('The universally unique job identifier.'),
    'schema field' => 'uuid',
    'extra_fields' => array('form'),
  );

  $properties['vuuid'] = array(
    'label' => t('Revision UUID'),
    'type' => 'integer',
    'description' => t('The universally unique job revision identifier.'),
    'schema field' => 'vuuid',
    'extra_fields' => array(),
  );

  $properties['bundle'] = array(
    'label' => t('Bundle'),
    'type' => 'text',
    'description' => t('The job bundle.  This value is always job.'),
    'schema field' => 'bundle',
    'extra_fields' => array('display'),
  );

  $properties['title'] = array(
    'label' => t('Title'),
    'type' => 'text',
    'description' => t('The name of the job.'),
    'schema field' => 'title',
    'extra_fields' => array('form', 'display'),
  );

  $properties['reference'] = array(
    'label' => t('External Reference'),
    'type' => 'text',
    'description' => t('A reference identifier for the job in another system.'),
    'schema field' => 'reference',
    'extra_fields' => array('form', 'display'),
  );

  $properties['details'] = array(
    'label' => t('Details'),
    'type' => 'text',
    'description' => t('Detailed notes about the job.'),
    'schema field' => 'reference',
    'extra_fields' => array('form', 'display'),
  );

  $properties['jsid'] = array(
    'label' => t('Status'),
    'type' => 'integer',
    'description' => t('The current status of the job.'),
    'options list' => 'wf_job_status_list',
    'schema field' => 'jsid',
    'extra_fields' => array('form', 'display'),
  );

  $properties['owner'] = array(
    'label' => t('Owner'),
    'type' => 'user',
    'description' => t('The user who owns the job.'),
    'schema field' => 'owner',
    'extra_fields' => array('form', 'display'),
  );

  $properties['assigned'] = array(
    'label' => t('Assignee'),
    'type' => 'user',
    'description' => t('The user who the job is currently assigned to.'),
    'schema field' => 'assigned',
    'extra_fields' => array('form', 'display'),
  );

  $properties['eid'] = array(
    'label' => t('Environment'),
    'type' => 'wf_environment',
    'description' => t('The current environment for the job.'),
    'schema field' => 'eid',
    'extra_fields' => array('form', 'display'),
  );

  $properties['created'] = array(
    'label' => t('Created'),
    'type' => 'date',
    'description' => 'Date when the job was created',
    'schema field' => 'created',
    'extra_fields' => array('form', 'display'),
  );

  $properties['modified'] = array(
    'label' => t('Modified'),
    'type' => 'date',
    'description' => 'Date when the job was last modified',
    'schema field' => 'created',
    'extra_fields' => array('form', 'display'),
  );

  $properties['url'] = array(
    'label' => t('URL'),
    'description' => t("The URL of the job's view page."),
    'getter callback' => 'wf_job_entity_metadata_get_properties',
    'type' => 'uri',
    'computed' => TRUE,
    'extra_fields' => array('form', 'display'),
  );

  $properties['edit_url'] = array(
    'label' => t('Edit URL'),
    'description' => t("The URL of the job's edit page."),
    'getter permission' => 'manage jobs',
    'getter callback' => 'wf_job_entity_metadata_get_properties',
    'type' => 'uri',
    'computed' => TRUE,
    'extra_fields' => array('form', 'display'),
  );

  $info['wf_job'] = array('properties' => $properties);
  $info['wf_job_bundle'] = array('properties' => array());

  $status_properties = array();

  $status_properties['status'] = array(
    'label' => t('Status'),
    'type' => 'text',
    'description' => t('The status label of job status.'),
    'schema field' => 'status',
    'extra_fields' => array('form', 'display'),
    'setter callback' => 'entity_property_verbatim_set',
  );

  $status_properties['machine_name'] = array(
    'label' => t('Machine Name'),
    'type' => 'text',
    'description' => t('The machine name for job status.'),
    'schema field' => 'machine_name',
    'extra_fields' => array('form', 'display'),
    'setter callback' => 'entity_property_verbatim_set',
  );

  $status_properties['module'] = array(
    'label' => t('Module'),
    'type' => 'text',
    'description' => t('The name of the providing module.'),
    'schema field' => 'module',
    'extra_fields' => array('form', 'display'),
    'setter callback' => 'entity_property_verbatim_set',
  );

  $status_properties['export_state'] = array(
    'label' => t('Export State'),
    'type' => 'integer',
    'description' => t('The exportable status of the status.'),
    'schema field' => 'export_state',
    'extra_fields' => array('form', 'display'),
    'setter callback' => 'entity_property_verbatim_set',
  );

  $status_properties['system_status'] = array(
    'label' => t('System Status'),
    'type' => 'text',
    'description' => t('The current system status.'),
    'schema field' => 'system_status',
    'extra_fields' => array('form', 'display'),
    'setter callback' => 'entity_property_verbatim_set',
  );

  $info['wf_job_status'] = array('properties' => $status_properties);

  return $info;
}

/**
 * Checks if a bundle exists.
 *
 * @param $name
 *   The bundle to look up.
 *
 * @return bool
 *   Does the bundle exist?
 */
function wf_job_bundle_exists($name) {
  $bundles = wf_job_load_bundles();
  return isset($bundles[$name]);
}

/**
 * Returns all defined job bundles.
 *
 * @return array
 */
function wf_job_load_bundles() {
  $bundles = &drupal_static(__FUNCTION__);

  if (empty($bundles)) {
    $cache = cache_get('wf_job_load_bundles');
    if ($cache) {
      $bundles = $cache->data;
    }
    else {
      $bundles = db_select('wf_job_bundle', 'wjb')
        ->fields('wjb')
        ->orderBy('bundle')
        ->execute()
        ->fetchAllAssoc('bundle');
      cache_set('wf_job_load_bundles', $bundles, 'cache');
    }
  }

  return $bundles;
}

/**
 * Checks if a status job exists.
 *
 * @param $name
 *   The status to look up.
 *
 * @return bool
 *   Does the status exist?
 */
function wf_job_status_exists($name) {
  return (bool) db_select('wf_job_status', 'wjs')
    ->condition('machine_name', $name)
    ->countQuery()
    ->execute()
    ->fetchField();
}

/**
 * Returns defined job status by name.
 *
 * @param $name
 *   The status to look up.
 *
 * @return object
 */
function wf_job_load_status_by_name($name) {
  $statuses = wf_job_status_load_all('status');
  return isset($statuses[$name]) ? $statuses[$name] : array();
}

/**
 * Returns defined job status by jsid.
 *
 * @param $jsid
 *   The status id to look up.
 *
 * @return object
 */
function wf_job_load_status($jsid) {
  $statuses = wf_job_status_load_all('jsid');
  return isset($statuses[$jsid]) ? $statuses[$jsid] : array();
}

/**
 * Returns all defined job status.
 *
 * @return array
 */
function wf_job_status_load_all($fetch = 'system_status') {
  $cache = &drupal_static(__FUNCTION__ . $fetch);

  if (!isset($cache)) {
    $cache = db_select('wf_job_status', 'wjs')
      ->fields('wjs')
      ->orderBy('status')
      ->execute()
      ->fetchAllAssoc($fetch);
  }

  return $cache;
}

/**
 * Creates a new job object.
 */
function wf_job_create($values = array()) {
  return entity_create('wf_job', $values);
}

/**
 * Deletes a job object.
 */
function wf_job_delete(WfJob $job) {
  $job->delete();
}

/**
 * Deletes multiple jobs.
 *
 * @param $ids array
 *   A list of job ids to delete.
 */
function wf_job_delete_multiple(array $ids) {
  entity_delete('wf_job', $ids);
}

/**
 * Loads a job object.
 */
function wf_job_load($id = NULL, $reset = FALSE) {
  $ids = (isset($id) ? array($id) : array());
  $job = wf_job_load_multiple($ids, $reset);
  return $job ? reset($job) : FALSE;
}

/**
 * Loads one or more job objects.
 */
function wf_job_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('wf_job', $ids, $conditions, $reset);
}


/**
 * Saves a job.
 *
 * @param $job WfJob
 * The job to save.
 */
function wf_job_save($job) {
  $job->modified = REQUEST_TIME;
  if (empty($job->jid) || !empty($job->is_new)) {
    $job->created = REQUEST_TIME;
    $job->uid = $GLOBALS['user']->uid;
  }
  entity_save('wf_job', $job);
}

// /Entity CRUD

/**
 * Look up a job id using the reference value.
 *
 * @param $ref string
 *  The reference to look up.
 *
 * @return array
 *   List of ids found.
 */
function wf_job_id_by_reference($ref) {
  $query = new EntityFieldQuery();
  $jobs = $query->entityCondition('entity_type', 'wf_job')
    ->propertyCondition('reference', $ref)
    ->execute();

  return $jobs;
}

/**
 * Returns an array containing the used references by job, against a string.
 *
 * @param array $references
 *   An array containing the references.
 *
 * @return array
 *   An array keyed by Job Id containing the values ​​of the references.
 */
function wf_job_get_jobs_by_references($references) {
  $jobs = array();

  foreach ($references as $reference) {
    $result = db_select('wf_job', 'wf')
      ->fields('wf', array('jid', 'reference'))
      ->condition('reference', '%' . db_like(trim($reference)) . '%', 'LIKE')
      ->execute()
      ->fetchAllKeyed();

    if ($result) {
      foreach ($result as $jid => $retrieved_references) {
        $splitted_references = wf_job_split_references($retrieved_references);
        if (in_array($reference, $splitted_references)) {
          $jobs[$jid][] = $reference;
        }
      }
    }
  }

  return $jobs;
}

/**
 * Splits a reference string value, separeted by comma and space to an array.
 *
 * @param string $references
 *   The references string to be splitted.
 */
function wf_job_split_references($references) {
  preg_match_all("/[^\s,]+/", $references, $matches);

  return reset($matches);
}

/**
 * Fetches a list of job status values.
 *
 * @return array
 *   List of job statuses.
 */
function wf_job_status_list($key = 'jsid') {
  $cache_key = 'wf_job_status_list';

  if ('machine_name' == $key) {
    $cache_key = 'wf_job_status_list_machine_name';
  }

  $statuses = &drupal_static(__FUNCTION__);
  if (empty($statuses)) {
    $cached = cache_get($cache_key);
    if ($cached) {
      $statuses = $cached->data;
    }
    else {
      $statuses = db_select('wf_job_status', 'wfs')
        ->fields('wfs', array($key, 'status'))
        ->orderBy('status')
        ->execute()
        ->fetchAllKeyed();

      cache_set($cache_key, $statuses, 'cache');
    }
  }
  return $statuses;
}

/**
 * Fetches a list of job statuses keyed by machine name.
 */
function wf_job_machine_name_status_list() {
  return wf_job_status_list('machine_name');
}

/**
 * List of job system status values.
 *
 * @return array
 *   List of system statuses.
 */
function wf_job_system_status_list() {
  $system_statuses = array(
    'new',
    'started',
    'in review',
    'approved',
    'being deployed',
    'completed',
    'needs attention',
    'custom',
  );

  return array_combine($system_statuses, $system_statuses);
}

/**
 * List of job machine name status values.
 *
 * @return array
 *   List of machine name statuses.
 */
function wf_job_machine_name_list() {
  $status = &drupal_static(__FUNCTION__, array());

  if (!empty($status)) {
    return $status;
  }

  $machine_name_statuses = wf_job_status_load_all();

  foreach ($machine_name_statuses as $machine_name_status) {
    $status[$machine_name_status->machine_name] = $machine_name_status->status;
  }

  return $status;
}

/**
 * Preprocess function for wf_job.
 */
function wf_job_preprocess_wf_job(&$variables) {
  $sanitize = array(
    'jid',
    'title',
    'details',
  );

  $external_reference = $variables['elements']['#job']->reference;
  $reference = '';
  $plugin = variable_get('wf_job_ext_ref_plugin');
  if (!$plugin && $external_reference) {
    $sanitize[] = 'reference';
    $reference = $external_reference;
  }
  elseif ($plugin && $external_reference) {
    $class = ctools_plugin_load_class('wf_job', 'external_reference', $plugin, 'handler');
    $hander = new $class();
    $render = $hander->generateExternalRef($variables['elements']['#job']);
    if (!empty($render)) {
      $reference = drupal_render($render);
    }
  }
  $variables['elements']['#job']->reference = $reference;

  foreach ($sanitize as $var) {
    $variables['elements']['#job']->{$var} = check_plain($variables['elements']['#job']->{$var});
  }

  $variables['elements']['owner_name'] = theme('username', array('account' => user_load($variables['elements']['#job']->owner)));
  $variables['elements']['assigned_name'] = theme('username', array('account' => user_load($variables['elements']['#job']->assigned)));
  $variables['elements']['created_date'] = format_date($variables['elements']['#job']->created);
}

/**
 * Provides a job sandbox uri.
 *
 * @param $job WfJob
 * The job for which a sandbox URI is sought
 */
function wf_job_sandbox_uri($job, $path = '') {
  // TODO make this pluggable.
  $slug = wf_job_slug($job->jid);
  $dev_env = wf_environment_dev();
  return wf_environment_app_uri($dev_env, $job);
}

/**
 * Provides the drush aliases for all current jobs.
 *
 * @return array
 * An array of aliases
 */
function wf_job_drush_aliases() {
  $new_id = variable_get('wf_job_jsid_new');
  $completed_id = variable_get('wf_job_jsid_completed');

  $query = new EntityFieldQuery();
  // Implement hook_entity_query_alter() if you need to change this.
  $jids = $query->entityCondition('entity_type', 'wf_job')
        ->propertyCondition('jsid', array($new_id, $completed_id), 'NOT IN')
        ->propertyOrderBy('jid')
        ->execute();

  $jobs = array();
  if (!empty($jids['wf_job'])) {
    $jobs = entity_load('wf_job', array_keys($jids['wf_job']));
  }

  $aliases = array(
    'job' => array(
      'remote-host' => variable_get('wf_sandbox_remote_host', 'localhost'),
    ),
  );

  foreach ($jobs as $job) {
    $job_uri = wf_job_sandbox_uri($job);
    $slug = wf_job_slug($job->jid);
    $aliases[$slug] = array(
      'parent' => '@job',
      'uri' => preg_replace('#^https?://#', '', $job_uri['path']),
      'root' => variable_get('wf_sandbox_basepath', '/srv/www') . "/$slug/",
    );
    $aliases[$job->reference] = array(
      'parent' => "@$slug",
    );
  }

  drupal_alter('wf_job_drush_aliases', $aliases);
  return $aliases;
}

/**
 * Implements hook_theme().
 */
function wf_job_theme() {
  $themes = array();
  $templates = drupal_get_path('module', 'wf_job') . '/includes';

  $themes['wf_job_add_list'] = array(
    'file' => 'wf_job.theme.inc',
    'variables' => array('content' => NULL),
    'path' => $templates,
  );

  $themes['wf_job_drush_aliases'] = array(
    'file' => 'wf_job.theme.inc',
    'variables' => array(
      'aliases' => array(),
    ),
    'path' => $templates,
  );

  $themes['wf_job'] = array(
    'file' => 'wf_job.theme.inc',
    'render element' => 'elements',
    'template' => 'wf_job',
    'path' => $templates,
  );

  return $themes;
}

/**
 * Provides the names of all users.
 *
 * @param string key
 *   A key into the 'job_users' view to select different lists of users. If
 *   omitted the default list is for all active users. Supported values include:
 *   - review_others
 *
 * @return array
 */
function wf_job_users($permission = 'manage jobs') {

  // Load the view and apply the filter.
  $view = views_get_view('job_users');
  $view->set_display('block');
  $view->exposed_input['permission'] = $permission;

  // Run the view
  $view->pre_execute();
  $view->execute();

  $users = array();
  foreach ($view->result as $result) {
    $users[$result->uid] = $result->realname_realname;
  }
  return $users;
}


/**
 * Provides the title of a menu callback.
 */
function wf_job_action_title($job, $action) {
  switch ($action) {
    case 'propose':
    case 'approve':
      $env = wf_environment_load($job->eid);
      if (empty($env->next_env_id)) {
        drupal_set_message(t("There is no next environment after @env", array('@env' => $env->env)), 'error');
      }
      else {
        $next_env = wf_environment_load($env->next_env_id);
        return t('@action for @environment', array('@action' => ucfirst($action), '@environment' => $next_env->env));
      }
    default:
      return t(ucfirst($action));
  }
}

/**
 * Trigger event notifications for job actions.
 */
function wf_job_action_event_invoke($event, $job) {
  $owner = user_load($job->owner);
  $assigned = user_load($job->assigned);
  $env = wf_environment_load($job->eid);
  $next_env = FALSE;

  if (!empty($env->next_env_id)) {
    $next_env = wf_environment_load($env->next_env_id);
  }

  if (empty($next_env)) {
    $next_env = entity_create('wf_environment', array('env' => 'None'));
  }

  rules_invoke_event_by_args("wf_job_$event", array(
    'job' => $job,
    'environment' => $env,
    'next_environment' => $next_env,
    'owner' => $owner,
    'assigned' => $assigned,
  ));
}

/**
 * Records the outcome of a deployment.
 *
 * @param object $job
 *   The WfJob
 * @param bool $succeeded
 *   Whether the deployment succeeded
 * @param string $message
 *   A comment about the deployment outcome.
 * @return
 *   TRUE
 */
function wf_job_deployment($job, $succeeded, $message) {
  $env = wf_environment_load($job->eid);
  $next_env = wf_environment_load($env->next_env_id);

  if ($succeeded) {
    $job->eid = $env->next_env_id;
    if ($next_env->next_env_id) {
      $job->setStatusName('Started');
      $rules_event = 'deployed';
      $log_type = 'wf_job_deployed';
    }
    else {
      $job->setStatusName('Completed');
      $rules_event = 'completed';
      $log_type = 'wf_job_completed';
    }
  }
  else {
    $job->setStatusName('Needs Attention');
    $rules_event = 'deployment_failed';
    $log_type = 'wf_job_deployment_failed';
  }

  $job->rules_event = $rules_event;

  wf_job_attach_log_to_entity($job, $message, $log_type);
  wf_job_save($job);

  return TRUE;
}

/**
 * Implements hook_block_info().
 */
function wf_job_block_info() {
  $blocks = array();

  $blocks['wf_job_env_status'] = array(
    'info' => t('Job environment status'),
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function wf_job_block_view($delta) {
  switch ($delta) {
    case 'wf_job_env_status':
      return wf_job_env_status_block();
  }
}

/**
 * Returns a the wf_job_env_status block.
 */
function wf_job_env_status_block() {
  $items = array();

  $job = menu_get_object('wf_job');
  if (empty($job)) {
    return array();
  }

  $status = wf_job_load_status($job->jsid);
  $class = array('passed');

  foreach (wf_environment_list() as $id => $env) {
    if ($job->eid == $id) {
      $class = array('current', $status->machine_name);
      $class[] = $env->env;
      $items[] = array('data' => t('@env: @status', array('@env' => $env->env, '@status' => $status->status)), 'class' => $class);
      continue;
    }
    $default_class = array($env->env);
    array_merge($default_class, $class);
    $items[] = array('data' => $env->env, 'class' => $default_class);
  }

  return array(
    'subject' => t('Job progress'),
    'content' => array(
      '#theme' => 'item_list',
      '#items' => $items,
      '#attributes' => array('class' => array('job-env-status')),
    ),
  );
}

/**
 * Implements hook_entity_insert().
 */
function wf_job_entity_insert($entity, $entity_type) {
  wf_job_entity_update($entity, $entity_type);
}

/**
 * Implements hook_entity_update().
 */
function wf_job_entity_update($entity, $entity_type) {
  if ('wf_job' == $entity_type) {
    if (!empty($entity->rules_event)) {
      wf_job_action_event_invoke($entity->rules_event, $entity);
    }
  }
}

/**
 * Returns a slug for the given job id.
 *
 * @param int $job_id
 */
function wf_job_slug($jid) {
  return format_string(variable_get('wf_job_slug_pattern', 'job@jid'), array('@jid' => $jid));
}

/**
 * Callback for getting properties of an entity.
 */
function wf_job_entity_metadata_get_properties($entity, array $options, $name, $entity_type) {
  switch ($name) {
    case 'url':
      $return = entity_uri($entity_type, $entity);
      return url($return['path'], $return['options'] + $options);

    case 'edit_url':
      $return = entity_uri($entity_type, $entity);
      return url($return['path'] . '/edit', $return['options'] + $options);

  }
}

/**
 * Returns the instantiated ctools wf_job visit plugin handler class.
 *
 * @throw WfJobUrlException
 *   When the plugin is undefined or problems lower in the stack.
 */
function wf_job_get_visit_plugin_handler() {
  ctools_include('plugins');
  $handler = &drupal_static(__FUNCTION__);
  if (!$handler) {
    $plugin = variable_get('wf_job_visit_plugin');
    if (!$plugin) {
      throw new WfJobUrlException(t('Undefined visit URL plugin'));
    }

    $class_name = ctools_plugin_load_class('wf_job', 'url_visit', $plugin, 'handler');
    $handler = new $class_name();
  }

  return $handler;
}

/**
 * Generates the sandbox URL.
 *
 * @param WfJob $job
 *  The job to generate the URL for.
 *
 * @return string
 *  The sandbox URL.
 */
function wf_job_sandbox_url(WfJob $job) {
  $handler = wf_job_get_visit_plugin_handler();

  $url = $handler->generateVisitLink($job);
  return $url;
}

/**
 * Redirects the user to view the sandbox site.
 */
function wf_job_visit(WfJob $job) {
  try {
    $url = wf_job_sandbox_url($job);
  }
  catch (Exception $e) {
    drupal_set_message(t('Unable to generate visit URL.'), 'error');
    $uri = entity_uri('wf_job', $job);
    return drupal_goto($uri['path'], $uri['options']);
  }
  drupal_goto($url);
}

/**
 * Implements hook_ctools_plugin_api().
 */
function wf_job_ctools_plugin_api($module, $api) {
  $apis = array(
    'acl',
    'sandbox_domain',
    'url_login',
    'url_visit',
    'url_ssh',
    'external_reference',
  );

  if ('wf_job' == $module && in_array($api, $apis)) {
    return array('version' => 1);
  }
}

/**
 * Implements hook_ctools_plugin_type().
 */
function wf_job_ctools_plugin_type() {
  $apis = array(
    'acl',
    'sandbox_domain',
    'url_login',
    'url_visit',
    'url_ssh',
    'external_reference',
  );

  $plugins = array();
  foreach ($apis as $api) {
    $plugins[$api] = array(
      'cache' => TRUE,
      'classes' => array('handler'),
      'use hooks' => TRUE,
    );
  }

  return $plugins;
}

/**
 * Default implementation for accessing a job sandbox.
 *
 * @param object $job
 *   The object of the related Job entity.
 */
function wf_job_login_page($job) {
  ctools_include('plugins');

  try {
    $plugin = variable_get('wf_job_login_plugin');
    if (!$plugin) {
      throw new WfJobUrlException(t('Undefined login URL plugin'));
    }

    $class_name = ctools_plugin_load_class('wf_job', 'url_login', $plugin, 'handler');
    $handler = new $class_name();

    $url = $handler->generateLoginLink($job);
    drupal_goto($url);
  }
  catch (Exception $e) {
    watchdog('wf_job_login_plugin', $e->getMessage());
    drupal_set_message(t('Unable to generate login URL.'), 'error');
  }

  $uri = entity_uri('wf_job', $job);
  return drupal_goto($uri['path'], $uri['options']);
}

/**
 * Fetches a list of plugins.
 *
 * @param  string $type
 *   The plugin type.
 * @return array
 *   An associative array of plugins keyed by name.
 */
function wf_job_get_plugins_list($type) {
  $plugins = array();
  foreach (ctools_get_plugins('wf_job', $type) as $name => $info) {
    $plugins[$name] = $info['title'];
  }
  return $plugins;
}

/**
 * Implements hook_wf_log_info().
 */
function wf_job_wf_log_info() {
  $logs = array();

  $logs['wf_job_started'] = array(
    'title' => t('Job started'),
    'description' => t('A new Job was started.'),
  );

  $logs['wf_job_proposed'] = array(
    'title' => t('Job proposed'),
    'description' => t('Job was proposed for review.'),
  );

  $logs['wf_job_saved'] = array(
    'title' => t('Job saved'),
    'description' => t('Job was saved.'),
  );

  $logs['wf_job_approved'] = array(
    'title' => t('Job approved'),
    'description' => t('Job was approved.'),
  );

  $logs['wf_job_rejected'] = array(
    'title' => t('Job rejected'),
    'description' => t('Job was rejected.'),
  );

  $logs['wf_job_deployed'] = array(
    'title' => t('Job deployed'),
    'description' => t('Job was deployed to a new environment.'),
  );

  $logs['wf_job_deployment_failed'] = array(
    'title' => t('Job deployment failed'),
    'description' => t('Job\'s deployment to a new environment fails.'),
  );

  $logs['wf_job_completed'] = array(
    'title' => t('Job completed'),
    'description' => t('Job was deployed to the final environment.'),
  );

  $logs['wf_job_update_code_submit'] = array(
    'title' => t('"Update code" button clicked'),
    'description' => t('User clicked on the Update code button.'),
  );

  $logs['wf_job_start_update_code'] = array(
    'title' => t('Code update started'),
    'description' => t('Code update was started for a job.'),
  );

  $logs['wf_job_updated_code'] = array(
    'title' => t('Job code updated'),
    'description' => t('Job code has been updated.'),
  );

  $logs['wf_job_to_dev'] = array(
    'title' => t('Returned to dev'),
    'description' => t('Returned job to dev environment.'),
  );

  $logs['wf_job_reallocate'] = array(
    'title' => t('Reallocate job'),
    'description' => t('Job assigned and owner has been updated.'),
  );

  return $logs;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function wf_job_ctools_plugin_directory($owner, $plugin_type) {
  if ('wf_job' == $owner) {
    return "plugins/{$plugin_type}";
  }
}

/**
 * Implements hook_wf_job_acl().
 */
function wf_job_wf_job_acl() {
  $plugins = array();

  $plugins['standard'] = array(
    'title' => t('Standard ACLs'),
    'description' => t('Standard permissions based access control system for WF Jobs.'),
    'handler' => 'WfJobAclStandard',
    'file' => 'plugins/acl/wf_job.WfJobAclStandard.class.php',
  );

  return $plugins;
}

/**
 * Update the status of a job.
 */
function wf_job_update_status(WfJob $job, $system_status) {
  $statuses = wf_job_status_load_all('machine_name');
  $job->jsid = $statuses[$system_status]->jsid;

  // Avoiding recursion.
  unset($job->rules_event);

  wf_job_save($job);
}

/**
 * Update the environment for a job.
 */
function wf_job_update_environment(WfJob $job, $env_id) {
  $job->eid = $env_id;

  // Avoiding recursion.
  unset($job->rules_event);

  wf_job_save($job);
}

/**
 * Extracts the system_status from the current status on a job.
 *
 * @param  EntityDrupalWrapper $job
 *   The structure of job.
 * @return string
 *   The current system_status on a job.
 */
function wf_job_get_system_status(EntityDrupalWrapper $job) {
  $status = $job->jsid->system_status->value();
  return $status;
}

/**
 * Add form log field to a form structure.
 *
 * @param array $form
 *   Form API structured array.
 */
function wf_job_attach_log_field_form(&$form) {
  if (module_exists('wf_log')) {
    $form['log'] = array(
      '#title' => t('Comment'),
      '#type' => 'textarea',
      '#required' => TRUE,
      '#description' => t('Please make a comment.'),
    );
  }
}

/**
 * Attach the log value and type to an entity to be saved.
 *
 * @param object $entity
 *   Entity object.
 *
 * @param string $log_value
 *   The log message.
 *
 * @param string $log_type
 *   The log_type.
 */
function wf_job_attach_log_to_entity(&$entity, $log_value, $log_type) {
  if (module_exists('wf_log')) {
    wf_log_attach_log_to_entity($entity, $log_value, $log_type);
  }
}

/**
 * Attach the form log field value and type to an entity to be saved.
 *
 * @param object $entity
 *   Entity object.
 *
 * @param array $form_state
 *   Form API form state structure.
 *
 * @param string $log_type
 *   The log type.
 */
function wf_job_attach_form_log_value_to_entity(&$entity, $form_state, $log_type) {
  if (isset($form_state['values']['log'])) {
    wf_job_attach_log_to_entity($entity, $form_state['values']['log'], $log_type);
  }
}
